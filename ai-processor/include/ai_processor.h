#pragma once

#include <string>
#include <vector>
#include <memory>
#include <optional>

namespace web_page_manager {
namespace ai {

/// Processing mode for AI content analysis
enum class ProcessingMode {
    Basic,    ///< Fast text-only processing
    Enhanced, ///< Full content analysis with media
    Auto      ///< Automatically choose based on content and resources
};

/// Content type classification
enum class ContentType {
    Article,
    Video,
    Documentation,
    SocialMedia,
    Shopping,
    News,
    Reference,
    Other
};

/// Page content structure
struct PageContent {
    std::string html;
    std::string text;
    std::string title;
    std::optional<std::string> description;
    std::vector<std::string> keywords;
    std::vector<std::string> images;
    std::vector<std::string> links;
};

/// Content summary generated by AI
struct ContentSummary {
    std::string summary_text;
    std::vector<std::string> key_points;
    ContentType content_type;
    std::string language;
    uint32_t reading_time_minutes;
    float confidence_score;
};

/// Category information
struct CategoryInfo {
    std::string primary_category;
    std::vector<std::string> secondary_categories;
    float confidence;
};

/// Group suggestion
struct GroupSuggestion {
    std::string group_name;
    std::string description;
    std::vector<std::string> page_ids;
    float similarity_score;
};

/// Relevance score between content
struct RelevanceScore {
    float score;
    std::vector<std::string> common_topics;
    std::vector<std::string> common_keywords;
};

/// Entity information extracted from content
struct EntityInfo {
    std::string name;
    std::string type;  // person, organization, location, product, etc.
    float confidence;
    std::vector<size_t> positions;  // positions in text where entity appears
};

/// Content analysis result
struct ContentAnalysis {
    ContentSummary summary;
    CategoryInfo category;
    std::vector<std::string> entities;
    std::vector<std::string> topics;
    std::string sentiment;
    std::vector<EntityInfo> detailed_entities;
    float sentiment_score;  // -1.0 (negative) to 1.0 (positive)
};

/// Topic information
struct TopicInfo {
    std::string main_topic;
    std::vector<std::string> sub_topics;
    float confidence;
};

/// Page structure information
struct PageStructure {
    size_t heading_count;
    size_t paragraph_count;
    size_t list_count;
    size_t table_count;
    size_t form_count;
    size_t media_count;
    std::vector<std::string> headings;
    std::vector<std::string> sections;
    bool has_navigation;
    bool has_sidebar;
    bool has_footer;
    float content_density;  // ratio of content to total page size
};

/// Cross-content recommendation
struct CrossRecommendation {
    std::string source_id;
    std::string target_id;
    float relevance_score;
    std::string reason;
    std::vector<std::string> common_topics;
};

/// Processing capabilities
struct ProcessingCapabilities {
    bool supports_enhanced_mode;
    bool supports_media_analysis;
    bool supports_sentiment_analysis;
    size_t max_content_length;
    std::vector<std::string> supported_languages;
};

/// Internal processor interface (not exposed to clients)
class IContentProcessor {
public:
    virtual ~IContentProcessor() = default;
    
    virtual ContentSummary GenerateSummary(const PageContent& content) = 0;
    virtual std::vector<std::string> ExtractKeywords(const PageContent& content) = 0;
    virtual CategoryInfo ClassifyContent(const PageContent& content) = 0;
    virtual double CalculateSimilarity(const ContentSummary& a, const ContentSummary& b) = 0;
};

/// Unified AI content processor interface
class AIContentProcessor {
public:
    AIContentProcessor();
    ~AIContentProcessor();
    
    // Prevent copying
    AIContentProcessor(const AIContentProcessor&) = delete;
    AIContentProcessor& operator=(const AIContentProcessor&) = delete;
    
    // Allow moving
    AIContentProcessor(AIContentProcessor&&) noexcept;
    AIContentProcessor& operator=(AIContentProcessor&&) noexcept;
    
    /// Core content analysis capabilities
    ContentSummary GenerateSummary(const PageContent& content);
    std::vector<std::string> ExtractKeywords(const PageContent& content);
    CategoryInfo ClassifyContent(const PageContent& content);
    
    /// Content similarity and grouping
    double CalculateSimilarity(const ContentSummary& a, const ContentSummary& b);
    std::vector<GroupSuggestion> SuggestGroups(const std::vector<PageContent>& pages);
    RelevanceScore CalculateContentRelevance(const PageContent& a, const PageContent& b);
    
    /// Advanced analysis (automatically uses enhanced mode if available)
    ContentAnalysis AnalyzePageStructure(const PageContent& content);
    std::vector<std::string> ExtractPageMetadata(const PageContent& content);
    TopicInfo IdentifyMainTopics(const PageContent& content);
    
    /// Enhanced page structure analysis
    PageStructure AnalyzePageLayout(const PageContent& content);
    
    /// Entity extraction from content
    std::vector<EntityInfo> ExtractEntities(const PageContent& content);
    
    /// Sentiment analysis
    std::pair<std::string, float> AnalyzeSentiment(const std::string& text);
    
    /// Cross-content recommendations
    std::vector<CrossRecommendation> GenerateCrossRecommendations(
        const std::vector<PageContent>& pages,
        float min_relevance = 0.5f
    );
    
    /// Configuration and optimization
    void SetProcessingMode(ProcessingMode mode);
    ProcessingMode GetProcessingMode() const;
    ProcessingCapabilities GetCurrentCapabilities() const;
    
private:
    class Impl;
    std::unique_ptr<Impl> impl_;
};

} // namespace ai
} // namespace web_page_manager
