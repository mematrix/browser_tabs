use std::collections::HashMap;

use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

/// Browser types supported by the system
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum BrowserType {
    Chrome,
    Firefox,
    Edge,
    Safari,
}

/// Tab identifier
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TabId(pub Uuid);

impl TabId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

/// Bookmark identifier
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct BookmarkId(pub Uuid);

impl BookmarkId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

/// History entry identifier
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct HistoryId(pub Uuid);

impl HistoryId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

/// Archive identifier
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ArchiveId(pub Uuid);

impl ArchiveId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

/// Tab information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TabInfo {
    pub id: TabId,
    pub url: String,
    pub title: String,
    pub favicon_url: Option<String>,
    pub browser_type: BrowserType,
    pub is_private: bool,
    pub created_at: DateTime<Utc>,
    pub last_accessed: DateTime<Utc>,
}

/// Bookmark information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BookmarkInfo {
    pub id: BookmarkId,
    pub url: String,
    pub title: String,
    pub favicon_url: Option<String>,
    pub browser_type: BrowserType,
    pub folder_path: Vec<String>,
    pub created_at: DateTime<Utc>,
    pub last_accessed: Option<DateTime<Utc>>,
}

/// Browser instance information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BrowserInstance {
    pub browser_type: BrowserType,
    pub version: String,
    pub process_id: u32,
    pub debug_port: Option<u16>,
    pub profile_path: Option<String>,
}

/// Browser connection handle
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BrowserConnection {
    pub browser_type: BrowserType,
    pub connection_id: String,
    pub is_connected: bool,
}

/// Page content extracted from web pages
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageContent {
    pub html: String,
    pub text: String,
    pub title: String,
    pub description: Option<String>,
    pub keywords: Vec<String>,
    pub images: Vec<String>,
    pub links: Vec<String>,
    pub extracted_at: DateTime<Utc>,
}

/// Content type classification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ContentType {
    Article,
    Video,
    Documentation,
    SocialMedia,
    Shopping,
    News,
    Reference,
    Other(String),
}

/// Content summary generated by AI
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContentSummary {
    pub summary_text: String,
    pub key_points: Vec<String>,
    pub content_type: ContentType,
    pub language: String,
    pub reading_time_minutes: u32,
    pub confidence_score: f32,
    pub generated_at: DateTime<Utc>,
}

/// Page source type
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PageSourceType {
    ActiveTab { browser: BrowserType, tab_id: TabId },
    Bookmark { browser: BrowserType, bookmark_id: BookmarkId },
    ClosedTab { history_id: HistoryId },
    ArchivedContent { archive_id: ArchiveId },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum PageRawSourceType {
    ActiveTab,
    Bookmark,
    ClosedTab,
    ArchivedContent,
}

/// Unified page information combining tabs and bookmarks
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnifiedPageInfo {
    pub id: Uuid,
    pub url: String,
    pub title: String,
    pub favicon_url: Option<String>,
    pub content_summary: Option<ContentSummary>,
    pub keywords: Vec<String>,
    pub category: Option<String>,
    pub source_type: PageSourceType,
    pub browser_info: Option<BrowserInstance>,
    pub tab_info: Option<TabInfo>,
    pub bookmark_info: Option<BookmarkInfo>,
    pub created_at: DateTime<Utc>,
    pub last_accessed: DateTime<Utc>,
    pub access_count: u32,
}

/// Smart group type
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GroupType {
    Domain(String),
    Topic(String),
    ContentType(ContentType),
    UserDefined,
    AIGenerated { algorithm: String, confidence: f32 },
}

/// Smart group for organizing pages
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SmartGroup {
    pub id: Uuid,
    pub name: String,
    pub description: String,
    pub group_type: GroupType,
    pub pages: Vec<Uuid>, // UnifiedPageInfo IDs
    pub created_at: DateTime<Utc>,
    pub auto_generated: bool,
    pub similarity_threshold: f32,
}

/// Bookmark accessibility status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AccessibilityStatus {
    Accessible,
    NotFound,
    Forbidden,
    Timeout,
    NetworkError(String),
}

/// UI framework selection
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum UIFramework {
    Flutter,
    WinUI,
    GTK,
    Qt,
}

/// UI data for cross-framework communication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UIData {
    pub pages: Vec<UnifiedPageInfo>,
    pub groups: Vec<SmartGroup>,
    pub active_browser_count: usize,
    pub last_updated: DateTime<Utc>,
}

/// Hotkey definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Hotkey {
    pub id: String,
    pub key_combination: String,
    pub action: String,
    pub description: String,
}

/// History entry for closed tabs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HistoryEntry {
    pub id: HistoryId,
    pub page_info: UnifiedPageInfo,
    pub browser_type: BrowserType,
    pub tab_id: Option<TabId>,
    pub closed_at: DateTime<Utc>,
    pub session_info: Option<SessionInfo>,
}

/// Session information for history entries
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionInfo {
    pub session_id: String,
    pub window_id: Option<String>,
    pub tab_index: Option<u32>,
    pub scroll_position: Option<u32>,
}

/// Filter for querying history entries
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct HistoryFilter {
    pub browser_type: Option<BrowserType>,
    pub from_date: Option<DateTime<Utc>>,
    pub to_date: Option<DateTime<Utc>>,
    pub url_pattern: Option<String>,
    pub title_pattern: Option<String>,
    pub limit: Option<usize>,
    pub offset: Option<usize>,
}

/// Retention policy for automatic history cleanup
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RetentionPolicy {
    pub max_age_days: u32,
    pub max_entries: usize,
    pub preserve_important: bool,
    pub importance_threshold: f32,
}

impl Default for RetentionPolicy {
    fn default() -> Self {
        Self {
            max_age_days: 30,
            max_entries: 10000,
            preserve_important: true,
            importance_threshold: 0.7,
        }
    }
}

/// Match information for tab-bookmark associations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MatchInfo {
    pub tab_id: TabId,
    pub bookmark_id: BookmarkId,
    pub match_type: MatchType,
    pub confidence: f32,
    pub matched_at: DateTime<Utc>,
}

/// Type of match between tab and bookmark
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MatchType {
    ExactUrl,
    SameDomain,
    SimilarContent,
    UserDefined,
}

/// Result of bookmark analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BookmarkAnalysisResult {
    pub bookmark: BookmarkInfo,
    pub accessibility_status: AccessibilityStatus,
    pub content_summary: Option<ContentSummary>,
    pub page_metadata: Option<PageMetadata>,
    pub analyzed_at: DateTime<Utc>,
    pub analysis_duration_ms: u64,
}

/// Page metadata extracted from web pages
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageMetadata {
    pub title: String,
    pub description: Option<String>,
    pub author: Option<String>,
    pub published_date: Option<DateTime<Utc>>,
    pub modified_date: Option<DateTime<Utc>>,
    pub language: Option<String>,
    pub og_image: Option<String>,
    pub canonical_url: Option<String>,
    pub site_name: Option<String>,
}

/// Group of duplicate bookmarks
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DuplicateGroup {
    pub id: Uuid,
    pub bookmarks: Vec<BookmarkInfo>,
    pub duplicate_type: DuplicateType,
    pub similarity_score: f32,
    pub suggested_keep: Option<BookmarkId>,
}

/// Type of duplication detected
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DuplicateType {
    ExactUrl,
    SameContent,
    SimilarTitle,
    RedirectChain,
}

/// Content analysis result from AI processor
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContentAnalysis {
    pub summary: ContentSummary,
    pub topics: Vec<TopicInfo>,
    pub entities: Vec<String>,
    pub sentiment: Option<SentimentInfo>,
    pub structure: PageStructure,
}

/// Topic information extracted from content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopicInfo {
    pub name: String,
    pub confidence: f32,
    pub keywords: Vec<String>,
}

/// Sentiment analysis result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SentimentInfo {
    pub overall: SentimentType,
    pub score: f32,
}

/// Sentiment type classification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SentimentType {
    Positive,
    Negative,
    Neutral,
    Mixed,
}

/// Page structure analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageStructure {
    pub has_navigation: bool,
    pub has_sidebar: bool,
    pub has_comments: bool,
    pub main_content_ratio: f32,
    pub heading_count: u32,
    pub image_count: u32,
    pub link_count: u32,
}

/// Group suggestion from AI
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GroupSuggestion {
    pub suggested_name: String,
    pub suggested_description: String,
    pub page_ids: Vec<Uuid>,
    pub group_type: GroupType,
    pub confidence: f32,
    pub reasoning: String,
}

/// Category information for content classification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CategoryInfo {
    pub primary_category: String,
    pub secondary_categories: Vec<String>,
    pub confidence: f32,
}

/// Relevance score between two pieces of content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RelevanceScore {
    pub score: f32,
    pub factors: Vec<RelevanceFactor>,
}

/// Factor contributing to relevance score
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RelevanceFactor {
    pub name: String,
    pub weight: f32,
    pub contribution: f32,
}

/// Browser information for unified page info
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BrowserInfo {
    pub browser_type: BrowserType,
    pub version: Option<String>,
    pub profile_name: Option<String>,
}

/// Creates a new BookmarkInfo from a TabInfo, inheriting all analyzed data
/// from the associated UnifiedPageInfo.
/// 
/// This function ensures data inheritance integrity as per Requirement 6.3:
/// When a user adds a tab as a bookmark, the new bookmark automatically inherits
/// the analyzed content summary and tags.
pub fn create_bookmark_from_tab(
    tab: &TabInfo,
    unified_page: &UnifiedPageInfo,
    folder_path: Vec<String>,
) -> (BookmarkInfo, UnifiedPageInfo) {
    let bookmark_id = BookmarkId::new();
    let now = Utc::now();
    
    // Create the bookmark with inherited data from tab
    let bookmark = BookmarkInfo {
        id: bookmark_id.clone(),
        url: tab.url.clone(),
        title: tab.title.clone(),
        favicon_url: tab.favicon_url.clone(),
        browser_type: tab.browser_type,
        folder_path,
        created_at: now,
        last_accessed: Some(now),
    };
    
    // Create a new UnifiedPageInfo for the bookmark that inherits
    // the content summary and keywords from the original unified page
    let bookmark_unified_page = UnifiedPageInfo {
        id: Uuid::new_v4(),
        url: tab.url.clone(),
        title: tab.title.clone(),
        favicon_url: tab.favicon_url.clone(),
        // Inherit content summary from the original unified page
        content_summary: unified_page.content_summary.clone(),
        // Inherit keywords from the original unified page
        keywords: unified_page.keywords.clone(),
        // Inherit category from the original unified page
        category: unified_page.category.clone(),
        source_type: PageSourceType::Bookmark {
            browser: tab.browser_type,
            bookmark_id: bookmark_id.clone(),
        },
        browser_info: unified_page.browser_info.clone(),
        tab_info: None,
        bookmark_info: Some(bookmark.clone()),
        created_at: now,
        last_accessed: now,
        access_count: 0,
    };
    
    (bookmark, bookmark_unified_page)
}