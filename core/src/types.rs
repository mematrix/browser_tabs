use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

/// Browser types supported by the system
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum BrowserType {
    Chrome,
    Firefox,
    Edge,
    Safari,
}

/// Tab identifier
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TabId(pub String);

impl TabId {
    pub fn new() -> Self {
        Self(Uuid::new_v4().to_string())
    }
}

/// Bookmark identifier
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct BookmarkId(pub String);

impl BookmarkId {
    pub fn new() -> Self {
        Self(Uuid::new_v4().to_string())
    }
}

/// History entry identifier
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct HistoryId(pub Uuid);

impl HistoryId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

/// Archive identifier
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ArchiveId(pub Uuid);

impl ArchiveId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

/// Tab information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TabInfo {
    pub id: TabId,
    pub url: String,
    pub title: String,
    pub favicon_url: Option<String>,
    pub browser_type: BrowserType,
    pub is_private: bool,
    pub created_at: DateTime<Utc>,
    pub last_accessed: DateTime<Utc>,
}

/// Bookmark information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BookmarkInfo {
    pub id: BookmarkId,
    pub url: String,
    pub title: String,
    pub favicon_url: Option<String>,
    pub browser_type: BrowserType,
    pub folder_path: Vec<String>,
    pub created_at: DateTime<Utc>,
    pub last_accessed: Option<DateTime<Utc>>,
}

/// Browser instance information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BrowserInstance {
    pub browser_type: BrowserType,
    pub version: String,
    pub process_id: u32,
    pub debug_port: Option<u16>,
    pub profile_path: Option<String>,
}

/// Browser connection handle
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BrowserConnection {
    pub browser_type: BrowserType,
    pub connection_id: String,
    pub is_connected: bool,
}

/// Page content extracted from web pages
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageContent {
    pub html: String,
    pub text: String,
    pub title: String,
    pub description: Option<String>,
    pub keywords: Vec<String>,
    pub images: Vec<String>,
    pub links: Vec<String>,
    pub extracted_at: DateTime<Utc>,
}

/// Content type classification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ContentType {
    Article,
    Video,
    Documentation,
    SocialMedia,
    Shopping,
    News,
    Reference,
    Other(String),
}

/// Content summary generated by AI
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContentSummary {
    pub summary_text: String,
    pub key_points: Vec<String>,
    pub content_type: ContentType,
    pub language: String,
    pub reading_time_minutes: u32,
    pub confidence_score: f32,
    pub generated_at: DateTime<Utc>,
}

/// Page source type
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PageSourceType {
    ActiveTab { browser: BrowserType, tab_id: TabId },
    Bookmark { browser: BrowserType, bookmark_id: BookmarkId },
    ClosedTab { history_id: HistoryId },
    ArchivedContent { archive_id: ArchiveId },
}

/// Unified page information combining tabs and bookmarks
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnifiedPageInfo {
    pub id: Uuid,
    pub url: String,
    pub title: String,
    pub favicon_url: Option<String>,
    pub content_summary: Option<ContentSummary>,
    pub keywords: Vec<String>,
    pub category: Option<String>,
    pub source_type: PageSourceType,
    pub browser_info: Option<BrowserInstance>,
    pub tab_info: Option<TabInfo>,
    pub bookmark_info: Option<BookmarkInfo>,
    pub created_at: DateTime<Utc>,
    pub last_accessed: DateTime<Utc>,
    pub access_count: u32,
}

/// Smart group type
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GroupType {
    Domain(String),
    Topic(String),
    ContentType(ContentType),
    UserDefined,
    AIGenerated { algorithm: String, confidence: f32 },
}

/// Smart group for organizing pages
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SmartGroup {
    pub id: Uuid,
    pub name: String,
    pub description: String,
    pub group_type: GroupType,
    pub pages: Vec<Uuid>, // UnifiedPageInfo IDs
    pub created_at: DateTime<Utc>,
    pub auto_generated: bool,
    pub similarity_threshold: f32,
}

/// Bookmark accessibility status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AccessibilityStatus {
    Accessible,
    NotFound,
    Forbidden,
    Timeout,
    NetworkError(String),
}

/// UI framework selection
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum UIFramework {
    Flutter,
    WinUI,
    GTK,
    Qt,
}

/// UI data for cross-framework communication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UIData {
    pub pages: Vec<UnifiedPageInfo>,
    pub groups: Vec<SmartGroup>,
    pub active_browser_count: usize,
    pub last_updated: DateTime<Utc>,
}

/// Hotkey definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Hotkey {
    pub id: String,
    pub key_combination: String,
    pub action: String,
    pub description: String,
}